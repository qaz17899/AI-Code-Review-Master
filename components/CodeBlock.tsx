import React, { useRef, useEffect, useState } from 'react';

const workerScript = `
  // We expect highlight.js and its languages to be loaded.
  // The main script URLs are from index.html
  try {
    importScripts('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js');
    importScripts('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js');
    importScripts('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/yaml.min.js');
    importScripts('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js');
    importScripts('https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js');
  } catch (e) {
    console.error('Error importing scripts in worker:', e);
  }

  self.onmessage = (event) => {
    const { code, lang } = event.data;
    if (!self.hljs) {
      // hljs did not load, return plain text
      self.postMessage(code);
      return;
    }
    try {
      const language = self.hljs.getLanguage(lang) ? lang : 'plaintext';
      const highlighted = self.hljs.highlight(code, { language, ignoreIllegals: true }).value;
      self.postMessage(highlighted);
    } catch (e) {
      // In case of highlighting error, return plain text
      self.postMessage(code);
    }
  };
`;


// --- OPTIMIZATION: Create Blob and URL once at the module level ---
// This avoids recreating the Blob and URL for every instance of CodeBlock,
// reducing memory usage and component mount time.
const workerBlob = new Blob([workerScript], { type: 'application/javascript' });
const workerUrl = URL.createObjectURL(workerBlob);

export const CodeBlock: React.FC<{ code: string, lang: string, isStreaming: boolean }> = ({ code, lang, isStreaming }) => {
    const codeRef = useRef<HTMLElement>(null);
    const [highlightedCode, setHighlightedCode] = useState<string | null>(null);
    const workerRef = useRef<Worker | null>(null);
    const highlightingTimer = useRef<ReturnType<typeof setTimeout> | null>(null);

    // Setup web worker for syntax highlighting
    useEffect(() => {
        const newWorker = new Worker(workerUrl);
        workerRef.current = newWorker;

        newWorker.onmessage = (event: MessageEvent<string>) => {
            setHighlightedCode(event.data);
        };

        return () => {
            newWorker.terminate();
        };
    }, []);

    // Effect to handle code changes and trigger highlighting
    useEffect(() => {
        // Clear any previous scheduled highlighting
        if (highlightingTimer.current) {
            clearTimeout(highlightingTimer.current);
        }
        const delay = isStreaming ? 100 : 0; // Use a short debounce while streaming

        highlightingTimer.current = setTimeout(() => {
            if (code) { // Only highlight if there's content
                workerRef.current?.postMessage({ code, lang });
            }
        }, delay);

        return () => {
            if (highlightingTimer.current) {
                clearTimeout(highlightingTimer.current);
            }
        };
    }, [code, lang, isStreaming]);

    // Use dangerouslySetInnerHTML to apply highlighted code.
    // This is the correct React way to handle HTML injection and works with Trusted Types CSP.
    // It's safe here because the HTML is generated by a trusted library (highlight.js)
    // from our own code content, not from external user input.
    const content = highlightedCode 
        ? { __html: highlightedCode } 
        : undefined;

    return (
        <pre className="p-4 overflow-x-auto text-sm text-slate-800 dark:text-slate-200 font-mono custom-scrollbar">
            {highlightedCode ? (
                <code className={`language-${lang}`} dangerouslySetInnerHTML={content} />
            ) : (
                <code ref={codeRef} className={`language-${lang}`}>{code}</code>
            )}
        </pre>
    );
};